import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import matplotlib.patches as patches
import numpy as np  # For plot_volume_with_averages if you choose to keep it

# --- General Plotting Setup (run this once in your notebook/script) ---
# %matplotlib inline # For Jupyter/Colab - run directly in a cell
plt.rcParams['figure.figsize'] = [18, 10]  # Default figure size
plt.rcParams['figure.dpi'] = 100  # Default DPI


# --- Plotting Individual Backtests (using cerebro.plot) ---
def plot_single_backtest(cerebro_obj, title="Backtest Plot"):
    """
    Plots the results of a single backtest using backtrader's built-in plotting.

    Args:
        cerebro_obj (bt.Cerebro): The cerebro object from a completed backtest run.
        title (str): Title for the plot.
    """
    print(f"\nPlotting: {title}")
    # Set figsize and dpi here if you want it specific to this plot, otherwise use global rcParams
    # plt.rcParams['figure.figsize'] = [18, 10] # Example: override global for this plot
    # plt.rcParams['figure.dpi'] = 100
    cerebro_obj.plot(iplot=False, style='candlestick')  # iplot=False ensures it doesn't open an interactive window
    plt.suptitle(title, y=1.02)  # Add a suptitle above the main plot title
    plt.show()  # Explicitly show the plot generated by cerebro.plot()


# --- Plotting Aggregated Portfolio Histories ---
def plot_all_portfolio_histories_by_time(all_portfolio_histories, title="Portfolio Value Over Time for All Coins", legend=True):
    """
    Plots the portfolio history for all backtests on a single chart.

    Args:
        all_portfolio_histories (dict): Dictionary of {'coin_name': portfolio_history_series (pd.Series)}.
        title (str): Title for the plot.
    """
    plt.figure(figsize=(20, 12))
    for coin_name, history_series in all_portfolio_histories.items():
        if not history_series.empty:
            # Ensure history_series is indeed a Series with datetime index
            if not isinstance(history_series.index, pd.DatetimeIndex):
                # This should not happen if run_backtest_for_df returns pd.Series correctly
                print(f"Warning: Portfolio history for {coin_name} does not have a DatetimeIndex. Attempting conversion.")
                history_series.index = pd.to_datetime(history_series.index)
            plt.plot(history_series.index, history_series.values, label=coin_name, alpha=0.7)
    plt.title(title)
    plt.xlabel("Date")
    plt.ylabel("Portfolio Value")
    if legend:
        plt.legend(loc='upper left', bbox_to_anchor=(1.01, 1.0), fontsize='small')
    plt.grid(True)
    plt.tight_layout()  # Adjusts plot to prevent labels from overlapping
    plt.show()


# --- Plotting Aggregated Portfolio Histories ---
def plot_all_portfolio_histories(all_portfolio_histories, title="Portfolio Value Over Time for All Coins", legend=True):
    """
    Plots the portfolio history for all backtests on a single chart.

    Args:
        all_portfolio_histories (dict): Dictionary of {'coin_name': portfolio_history_series (pd.Series)}.
        title (str): Title for the plot.
    """
    plt.figure(figsize=(20, 12))
    for coin_name, history_series in all_portfolio_histories.items():
        if not history_series.empty:
            # Ensure history_series is indeed a Series with datetime index
            if not isinstance(history_series.index, pd.DatetimeIndex):
                # This should not happen if run_backtest_for_df returns pd.Series correctly
                print(f"Warning: Portfolio history for {coin_name} does not have a DatetimeIndex. Attempting conversion.")
                history_series.index = pd.to_datetime(history_series.index)
            # plt.plot( history_series.values, label=coin_name, alpha=0.7)
            numeric_x = range(len(history_series))
            plt.plot(numeric_x, history_series.values, label=coin_name, alpha=0.7)

    plt.title(title)
    plt.xlabel("Trade Number")
    plt.ylabel("Portfolio Value")
    if legend:
        plt.legend(loc='upper left', bbox_to_anchor=(1.01, 1.0), fontsize='small')
    plt.grid(True)
    plt.tight_layout()  # Adjusts plot to prevent labels from overlapping
    plt.show()

# --- Plotting Aggregated Summary DataFrame ---


def draw_summary_df(summary_df):
    """
    Draws summary plots from the aggregated results DataFrame.

    Args:
        summary_df (pd.DataFrame): The DataFrame containing aggregated backtest results.
                                   Expected columns: 'file', 'total_profit', 'win_rate',
                                   'num_trades', 'final_value', 'initial_cash' (or similar).
    """
    # Ensure necessary columns exist. Adjust these names if your summary_df differs.
    # Example adaptation: Using 'final_value' and assuming initial_cash was 10_000_000.0
    # You might need to pass initial_cash to this function or store it in summary_df
    if 'final_value' not in summary_df.columns:
        print("Warning: 'final_value' column not found in summary_df. Cannot plot portfolio change.")
    if 'total_profit' not in summary_df.columns:
        print("Warning: 'total_profit' column not found in summary_df.")
    if 'win_rate' not in summary_df.columns:
        print("Warning: 'win_rate' column not found in summary_df.")
    if 'total_trades' not in summary_df.columns:  # Changed from num_trades
        print("Warning: 'total_trades' column not found in summary_df.")

    # 1. Final Value (equivalent to your 'total_profit' if starting cash is ignored, or adjusted)
    if 'final_value' in summary_df.columns:
        plt.figure(figsize=(12, 6))
        plt.bar(summary_df['coin'], summary_df['final_value'], color='skyblue')  # 'coin' from new results_df
        plt.xticks(rotation=90)
        plt.title("Final Portfolio Value per Coin")
        plt.ylabel("Value")
        plt.tight_layout()
        plt.show()

    # 2. Win Rate
    if 'win_rate' in summary_df.columns:  # Assuming you compute this in analyze_trades
        plt.figure(figsize=(12, 6))
        plt.plot(summary_df['coin'], summary_df['win_rate'], marker='o', color='green')
        plt.xticks(rotation=90)
        plt.title("Win Rate per Coin")
        plt.ylabel("Win Rate (%)")
        plt.ylim(0, 100)
        plt.grid(True)
        plt.tight_layout()
        plt.show()

    # 3. Number of Trades
    if 'total_trades' in summary_df.columns:  # Changed from num_trades
        plt.figure(figsize=(12, 6))
        plt.bar(summary_df['coin'], summary_df['total_trades'], color='orange')
        plt.xticks(rotation=90)
        plt.title("Number of Trades per Coin")
        plt.ylabel("Trades")
        plt.tight_layout()
        plt.show()

    # 4. Net Portfolio Change (Requires initial capital to be known or stored)
    # Assuming initial cash of 10,000,000.0 from your run_backtest_for_df
    initial_cash = 10_000_000.0
    if 'final_value' in summary_df.columns:
        summary_df["portfolio_change"] = summary_df["final_value"] - initial_cash
        plt.figure(figsize=(12, 6))
        plt.plot(summary_df['coin'], summary_df["portfolio_change"], marker='x', color='red')
        plt.xticks(rotation=90)
        plt.title("Portfolio Change per Coin")
        plt.ylabel("Change from Initial Capital")
        plt.axhline(0, color='black', linestyle='--')
        plt.grid(True)
        plt.tight_layout()
        plt.show()


# --- Adapted Custom Plot for Candlesticks with Enhanced Trades ---
# This function is for when backtrader's default trade plotting isn't enough.
# It assumes you're passing in the *original* dataframe (or a slice of it)
# and a 'trades' DataFrame you've prepared (e.g., from analyze_trades or a custom process).
def plot_candles_with_trades_custom(df, trades_df, only_around_trades=True, margin=60, drop_before=None, drop_after=None, title="Candlestick Chart with Trades"):
    """
    Plots a candlestick chart with custom trade visualizations (buy/sell markers and rectangles).
    This function is a standalone alternative to backtrader's trade observers if more customization is needed.

    Args:
        df (pd.DataFrame): The original OHLCV DataFrame (with 'datetime' as index).
        trades_df (pd.DataFrame): DataFrame of trades with 'buy_time', 'sell_time', 'buy_price', 'sell_price'.
        only_around_trades (bool): If True, filters the chart to show only around trade times.
        margin (int): Seconds margin around trades if only_around_trades is True.
        drop_before (float): If not None, filter candles where 'open' price is below this value.
        drop_after (float): If not None, filter candles where 'open' price is above this value.
        title (str): The title of the plot.
    """
    fig, ax = plt.subplots(figsize=(18, 9))
    # width for 1s interval (in days), adjusted for better visual density
    width = 0.7 / (24 * 60 * 60)  # width for 1 second in matplotlib's date format

    # Apply filtering based on marketcap/price (your original 'drop_before'/'drop_after' logic)
    filtered_df = df.copy()
    if drop_before is not None:
        start_idx = filtered_df[filtered_df['open'] >= drop_before].first_valid_index()
        if start_idx is not None:
            filtered_df = filtered_df.loc[start_idx:].copy()
        else:
            print("No candle reached 'drop_before' threshold. Adjusting plot range.")

    if drop_after is not None:
        end_idx = filtered_df[filtered_df['open'] > drop_after].last_valid_index()
        if end_idx is not None:
            filtered_df = filtered_df.loc[:end_idx].copy()
        else:
            print("No candle exceeded 'drop_after' threshold. Adjusting plot range.")

    if only_around_trades and not trades_df.empty:
        first_time = trades_df['buy_time'].min()
        last_time = trades_df['sell_time'].max()

        # Ensure datetime index for filtering
        if not isinstance(filtered_df.index, pd.DatetimeIndex):
            filtered_df.index = pd.to_datetime(filtered_df.index)

        mask = (filtered_df.index >= first_time - pd.Timedelta(seconds=margin)) & \
               (filtered_df.index <= last_time + pd.Timedelta(seconds=margin))
        filtered_df = filtered_df[mask]

    if filtered_df.empty:
        print("No data to plot after filtering.")
        return

    # Plot candles
    for idx, row in filtered_df.iterrows():
        color = 'green' if row['close'] > row['open'] else 'red'
        # Wick
        ax.plot([idx, idx], [row['low'], row['high']], color=color, linewidth=1)

        # Body
        rect = patches.Rectangle(
            (mdates.date2num(idx) - width / 2, min(row['open'], row['close'])),
            width,
            abs(row['close'] - row['open']),
            facecolor=color,
            edgecolor='black' if color == 'red' else 'green',  # Better visual
            alpha=0.8
        )
        ax.add_patch(rect)

    # Plot trades
    if not trades_df.empty:
        for _, trade in trades_df.iterrows():
            buy_time = trade['buy_time']
            sell_time = trade['sell_time']
            buy_price = trade['buy_price']
            sell_price = trade['sell_price']

            # Line markers
            ax.plot(buy_time, buy_price, marker='^', color='blue', markersize=10, zorder=5, label='Buy' if _ == 0 else "")
            ax.plot(sell_time, sell_price, marker='v', color='orange', markersize=10, zorder=5, label='Sell' if _ == 0 else "")

            # Rectangle from buy to sell
            trade_color = 'green' if trade['sell_price'] > trade['buy_price'] else 'red'
            # Convert datetime to numerical for Rectangle width calculation
            buy_time_num = mdates.date2num(buy_time)
            sell_time_num = mdates.date2num(sell_time)

            # Ensure sell_time_num is greater than buy_time_num for rectangle width
            if sell_time_num > buy_time_num:
                rect = patches.Rectangle(
                    (buy_time_num, min(buy_price, sell_price)),
                    sell_time_num - buy_time_num,
                    abs(sell_price - buy_price),
                    facecolor=trade_color,
                    alpha=0.3,
                    edgecolor=None,
                    zorder=2  # Ensure trades are behind markers but above candles
                )
                ax.add_patch(rect)

    ax.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
    plt.setp(ax.get_xticklabels(), rotation=45, ha="right")  # Rotate for readability
    ax.set_title(title)
    ax.set_xlabel('Time')
    ax.set_ylabel('Price')
    ax.grid(True)
    # ax.legend() # Only if you want 'Buy' and 'Sell' labels in legend
    plt.tight_layout()
    plt.show()

# --- Functions that are likely useless or have better backtrader alternatives ---
# def plot_candles(df): # Useless, covered by cerebro.plot()
# def plot_candles_and_rsi(df): # Useless for candles, RSI also better with bt.indicators.RSI + cerebro.plot() or custom observer

# --- Function to consider keeping separately if this specific analysis is needed ---


def plot_volume_with_averages(df):
    """
    Plots raw volume and several rolling mean volumes.
    This is a specialized analytical plot, not part of backtrader's core visualization.
    """
    # Filter to start after a certain 'open' price threshold (your original logic)
    # Ensure datetime index for filtering
    if not isinstance(df.index, pd.DatetimeIndex):
        df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')  # Assuming timestamp column exists
        df = df.set_index('datetime').sort_index()
    else:
        df = df.copy()  # Work on a copy to avoid SettingWithCopyWarning

    start_idx_value = 70000  # Example from your old code
    start_idx = df[df['open'] >= start_idx_value].first_valid_index()
    if start_idx is None:
        print(f"No candle reached an 'open' price of {start_idx_value}. Plotting entire DataFrame.")
        # If no candle meets the condition, you might plot the whole df or return
        # For now, let's proceed with the whole df if filter doesn't apply
        df_filtered = df
    else:
        df_filtered = df.loc[start_idx:].copy()

    if df_filtered.empty:
        print("No data to plot after filtering for volume averages.")
        return

    # Calculate rolling means
    df_filtered['vol_mean_5'] = df_filtered['volume'].rolling(window=5).mean()
    df_filtered['vol_mean_15'] = df_filtered['volume'].rolling(window=15).mean()
    df_filtered['vol_mean_30'] = df_filtered['volume'].rolling(window=30).mean()
    df_filtered['vol_mean_60'] = df_filtered['volume'].rolling(window=60).mean()

    # Use numeric x-axis to avoid gaps in time for bar plots
    x = np.arange(len(df_filtered))

    # Setup 5 vertically stacked subplots
    fig, axes = plt.subplots(5, 1, figsize=(15, 12), sharex=False)  # Increased figsize
    fig.subplots_adjust(hspace=0.6)  # Increased hspace for better separation

    # Determine colors based on candle direction
    colors = df_filtered.apply(lambda row: 'green' if row['close'] > row['open'] else 'red', axis=1)

    # 1. Raw volume (using 5-candle mean as a smoother representation, as in your original code)
    axes[0].bar(x, df_filtered['volume'], color=colors, width=0.8)  # Raw volume
    axes[0].set_title("Volume")
    axes[0].set_ylabel("Vol")

    # 2–5. Rolling averages
    axes[1].bar(x, df_filtered['vol_mean_5'], color='blue', width=0.8)
    axes[1].set_title("5-Candle Mean Volume")
    axes[1].set_ylabel("Vol M5")

    axes[2].bar(x, df_filtered['vol_mean_15'], color='purple', width=0.8)
    axes[2].set_title("15-Candle Mean Volume")
    axes[2].set_ylabel("Vol M15")

    axes[3].bar(x, df_filtered['vol_mean_30'], color='orange', width=0.8)
    axes[3].set_title("30-Candle Mean Volume")
    axes[3].set_ylabel("Vol M30")

    axes[4].bar(x, df_filtered['vol_mean_60'], color='black', width=0.8)
    axes[4].set_title("60-Candle Mean Volume")
    axes[4].set_ylabel("Vol M60")

    # Set x-axis labels to show dates from the DataFrame
    # Determine tick locations based on data density
    num_ticks = min(10, len(df_filtered) // 10)  # Max 10 ticks, or fewer for short data
    if num_ticks > 0:
        tick_indices = np.linspace(0, len(df_filtered) - 1, num_ticks, dtype=int)
        tick_labels = [df_filtered.index[i].strftime('%H:%M:%S') for i in tick_indices]
        for ax in axes:
            ax.set_xticks(tick_indices)
            ax.set_xticklabels(tick_labels, rotation=45, ha='right')

    for ax in axes:
        ax.grid(True)

    plt.tight_layout()
    plt.show()
